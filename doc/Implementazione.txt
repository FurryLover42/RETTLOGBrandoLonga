Implementazione

(Inserire immagine architettura)

Da bravi programmatori la prima cosa che abbiamo fatto è suddividere un problema complesso in molti sotto-problemi semplici.

-Comunicazione con RAM
-Identificazione WZ
-Calcolo risultato

Abbiamo trovato che l'approccio migliore è quindi la creazione di una macchina a stati finiti.
Ci siamo basati su una classica macchina di Mealy (Inserire prima immagine trovata su Google per "Mealy Machine").

L'implementazione è quindi basata su 3 macro-processi
-State Register: Ad ogni ciclo di clock porta la FSM al prossimo stato
-Calc process: In base allo stato in cui si trova esegue una serie di operazioni e decide il prossimo stato
-Speak to RAM: Processo di comunicazione con RAM

La macchina a stati finiti è così composta (Immagine di FSM)
Dove gli stati in (COLOR_RAM_COMM) rappresentano la comunicazione con RAM, sono a gruppi di 3 stati perchè l'operazione di comunicazione impiega 3 cicli di clock, uno per la richiesta, uno per la risposta ed uno per la lettura;
Gli stati in (COLOR_OPERATION) rappresentano calcoli aritmetico/logici;
Gli stati in (COLOR_IDLE) rappresentano gli stati in cui la macchina aspetta segnali di controllo esterni.

Segue una succinta descrizione del comportamento di ogni stato:
START_IDLE:			si va in questo stato in seguito al segnale di reset a prescindere dallo stato attuale, e ci si resta finché start = 0
ADD_ASK_STATE:      richiede l'indirizzo da codificare alla RAM
ADD_WAIT_RESPONSE:	stato di attesa per permettere alla RAM di processare la richiesta
ADD_READING_STATE:  legge l'indirizzo da codificare dalla RAM
WZ_ASK_STATE:		richiede l'i-esima wz alla RAM
WZ_WAIT_RESPONSE:	stato di attesa per permettere alla RAM di processare la richiesta
WZ_READING_STATE:	legge la i-esima working zone e va in WZ_CALC_STATE. Se invece non ci sono altre wz da leggere, va in NO_WZ_ENCODING
WZ_CALC_STATE:		calcola se l'address appartiene alla working zone corrente
WZ_DECISION:		in base a quanto fatto da WZ_CALC_STATE decide se passare a FOUND_WZ_ENCODING o WZ_ASK_STATE
FOUND_WZ_ENCODING:	codifica la parola da scrivere nella ram in encoded_res, quindi va in WRITING_STATE
NO_WZ_ENCODING:		codifica la parola da scrivere nella ram in encoded_res, quindi va in WRITING_STATE
WRITING_STATE:		scrive nella ram il contenuto di encoded_res, quindi va in WRITING_WAIT
WRITING_WAIT:		stato di attesa per permettere alla RAM di processare la richiesta, quindi va in DONE_WAIT
DONE_IDLE:			mantiene alto il segnale di done; quando il segnale di start si abbassa, va in END_IDLE
END_IDLE:			resta qui finché i_start = '0', quindi torna in START_IDLE